

<!-- INTRODUCTION SECTION -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link 
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
  />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    }
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">




  <header>
    <h1>Fractal Geometry 
	    Module 5 Lab Report</h1>
    <p class="author">
      Annkid Joseph Milc√© <br />
      04/13/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
In this report, we are going to document, extend, and analyze a python code that that represents an infinite dust.
In mathematics, the term infinite dust refers to a set of real nummbers with some remarkable properties. This set
is aslo known as the cantor set as many believe that it was discovered by Geor Cantor in 1883 although some sources 
mention that they were discovered by Henry John Setephen Smith in 1874. It is somehow, one of the first examples of
fractal. One way to get a cantor set is to start with a line segment, with the middle third of it, and repeat the 
process with the remaining shorter segments. The set resulting from this process is known as the Cantor ternary set.
Below, we will document and explain the a code that generates a Cantor set.
        </p>
     
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">                
import numpy as np
import matplotlib.pyplot as plt
x_start = 0        
x_end = 3         
y_position = 0     
bar_height = 5     
spacing = 10     
depth = 6         
	</code></pre>
The code above serves to important the necessary libraries and to set the initial parameters for the experiment.
Numpy was imported as np to provide support for numerical operations including handling arrays, and matplotlib.pyplot
to create static, animated, and interactive visualizations. When it comes to setting the initial parameters, the 
starting x_coordinate and the ending x_coordinate for the first bar are creares suing "x_start" and "x_end" while 
the "y-position" starts the starting y-coordinate which represents the start of the first bar. "bar_height" represents
the height of each segment of the infinite dust set, the "spacing" sets the vertical distance between successive levels 
of bars, and the "depth" parameters determines the number or recursive levels to generate the set.
</p>
		
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
	    
        <section id="code">
	<pre><code class="language-python">  
def cantor_set(x_start, x_end, y_position, depth):
    if depth == 0:
        return []
   
left_segment = [[x_start, x_start + (x_end - x_start) / 3, y_position]]
right_segment = [[x_end - (x_end - x_start) / 3, x_end, y_position]]
 
left_recursive = cantor_set(x_start, x_start + (x_end - x_start) / 3, y_position - spacing, depth - 1)
right_recursive = cantor_set(x_end - (x_end - x_start) / 3, x_end, y_position - spacing, depth - 1)
 
return left_segment + right_segment + left_recursive + right_recursive

	</code></pre>
The code above first defines the fucntion that will genersate the Cantor set pattern. The function takes the four
parameters described in the previous code segment. The function will return an empty list if the depth is zero which
means that no more segment is to be generated. Otherwise, the segment are defined such that "left_segment" returns 
the left third of the current segment while the "right_segment" will return the right third of the segment; both of
which will be represented as lists contiaining the x-coordinates and the actual y-coordinate. With the "left_recursive"
and the "right_recursive" commands, the function is recursively called twice in order to generate the the left and right 
segments for the next depth level moving downwards by spacing. Finally, the the "return" command returns a combination 
of the current segments including the ones created from recursive calls. 

<!-- ------------------------------------------------------------------------------------------------- -->
	    
        <section id="code">
	<pre><code class="language-python"> 
# Generate Cantor Set segments data
segments = np.array(cantor_set(x_start, x_end, y_position, depth))  # Convert to an array for easy plotting

# Plot the Cantor Set
plt.figure(figsize=(25, 25))

# Draw each segment as a black bar
for x_start, x_end, y in segments:
    plt.fill_between([x_start, x_end], [y] * 2, [y - bar_height] * 2, color="black")

# Hide the axes for a clean look
plt.axis('off')
plt.show()

</code></pre>
Above is the remaining code that will generate the Cantor set segment data as well as organizing the representation.
For easy manipulations and plotting, the first line of the code ensures that the segments created by the Cantor_set
function are converted into a NumPy array. The next line creates a new figure with an indicated size of 25 x 25 units.
A "for" loop was used to draw the segments as filled black bars between specified x-coordinates and defined heights.
The two ultimate code lines hide the axis for a better visual appearance and plot the images for vizualisation respectively.
		
<figure>
          <img
            src=" https://amilce2023.github.io/labreports/module5image1.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Cantor set generated from implementing a Google Colab code.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>   	
</code></pre>
In this section, we provide a modified and extended code whose goal is to creates a more appealing animated Cantor set.
	</p>
		
 <section id="code">
	<pre><code class="language-python"> 
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.animation import FuncAnimation, PillowWriter
from IPython.display import Image, display

x_start = 0
x_end = 3
bar_height = 5
spacing = 10
max_depth = 6

def cantor_set(x_start, x_end, y_position, depth, max_depth):
    if depth == 0:
        return []

    third = (x_end - x_start) / 3
    color = cm.viridis(depth / max_depth)  # Change to 'viridis' for a colorful gradient
    left = [[x_start, x_start + third, y_position, color]]
    right = [[x_end - third, x_end, y_position, color]]
    left_rec = cantor_set(x_start, x_start + third, y_position - spacing, depth - 1, max_depth)
    right_rec = cantor_set(x_end - third, x_end, y_position - spacing, depth - 1, max_depth)
    return left + right + left_rec + right_rec
fig, ax = plt.subplots(figsize=(10, 6))
ax.set_axis_off()

def update(frame):
    ax.clear()
    ax.set_axis_off()
    ax.set_title(f"Cantor Set - Depth {frame}", fontsize=14)
    segments = cantor_set(x_start, x_end, 0, frame, max_depth)
    for x0, x1, y, color in segments:
        ax.fill_between([x0, x1], [y]*2, [y - bar_height]*2, color=color)

anim = FuncAnimation(fig, update, frames=range(1, max_depth + 1), interval=1000, repeat=False)
gif_path = "/content/cantor_set.gif"
anim.save(gif_path, writer=PillowWriter(fps=1))
display(Image(filename=gif_path))


</code></pre>
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          This experiment is conducted by generating a Google Colab code that creates a fractal tree by
	  moving a turtle on a canvas. The code was modified and extended to create a more appealing tree and the 
	  functionality of the code. The way the code was modified creates a fractal tree that is different to the 
	  one genersted by the original code in the sense that it offers more variation in the visualization of the
          the results. With the introduction of a function that colors the tree based on the depth of the recursion, 
	  enhances the output as the tree is changing from one color to another. In this code, it transitions from 
	  green to yellow then to red and thus enhancing the tree's appearance as if it is growing different season 
	  of the year. Another way the modified and extended code enhances the visual look of the tree is in the sense 
	  that the branches are more complex. The functions "fractal_tree" and "build_tree" create very complex structures
	  that portray a natural tree and the user can adjust the parameters to to create different tree shapes. A great
	  change in the code is the use of the "reset_and_draw function". That feature makes sure that each previous tree
	  is cleared before generating a new tree. That avoids cluttering the canvas as new trees are created. These are
	  many changes that were done in the original code. The results can be seen in the diagram below.


      </section>
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module5image2.gif"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> A square drawn by moving the turtle in the canvas.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>   
      
      </section>



      <!-- CONCLUSION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
	In conclusion, this report highlights the steps that we used to generate a code that aims at creating a fractal
	tree, also known as a canopy, by recursion. The first portion of the original code gives birth to a not so complex
	tree. The code code was then changed to create a true that looks fuller with many other brsnches added. At the
	end of the experiment, we modified and extend to create a more complex tree that mimic a real life one by adding
	some other functions like the "get_color" function. The changes in the original code enhances the visualization
	of the prevously created trees as can be observed in Figure 3. 
		
         </p>
      </section>

     
     

      <!-- REFERENCE SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>References</h2>
        <p>     
       https://en.wikipedia.org/wiki/Fractal_canopy

	</p>
	    
     
  </main>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>


