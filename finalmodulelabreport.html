
 

<!-- INTRODUCTION SECTION -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link 
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
  />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    }
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">




  <header>
    <h1>Fractal Geometry 
	    Module 6 Lab Report</h1>
    <p class="author">
      Annkid Joseph Milcé <br />
      04/11/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
This is a report the final module report for the course fractal geomerty. In this module, we worked with the "Chaos
game" and the "L-Systems" to create fractals, and we concluded the the module by using "Turtle Graphics" to create
Hilbert curves. The term chaos game is method of creating fractals using a polygon and an initial point selected 
at random. The term is defined to be an algorithm that identifies points in the plane and was coined by the American
Mathematician Michael Barnsler]y. The first two codes will document and analyze in this report will generate will
generate a Sierpeński triangle and a Barnsley fern. Next, we will document and analyze a code that uses the L-Systems
to create a fractal tree. The L-Systems was introduced by Aristid Lindenmayer as a theoritical framework to study 
the development of multicellular organisms and then applied to investigate plants. The application of this system was
to plants description was studied by biologists and include various genreal mathematical methods. "After the 
incorporation of geometric features, plant models expressed using L-systems became detailed enough to allow the
use of computer graphics for realistic visualization of plant structures and developmental processes". Finally, we
will analyze a code that generates Hilbert curves, also known as the Hilbert space-filling curve. It is a type of
Lindenmayer system invented by the German mathematician and philosopher of mathematics David Hilbert in 1891 whose
limit is plane-filling function that fills a square. The code being so many, we will only provide snippets of the codes
and and document only the most important aspect of each of the code. Nonetheless, we shall provide snippets of key
modifications that were done to extend them followed by an analysis of what each modified and extended code does.
        </p>
     
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">                
import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'b', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()
	</code></pre>
Above is the first code of the module whose purpose it to generate a Sierpinski triangle using the chaos game algorithm. The code 
starts by defining the vertices of the triangle and initializes a starting point in a 2D space. The “midpoint” function calculates 
the midpoint between two points, which is crucial in generating the fractal. In a loop, the code randomly selects one of the triangle's 
vertices and computes the new point as the midpoint between the selected vertex and the last generated point. The process is repeated 
for a specified number of iterations which results in bunch of scattered set of points that visually represent the Sierpinski triangle. 
Finally, the points are plotted using Matplotlib to ensure visualization of the results which can be seen in the picture below.
</p>

<figure>
          <img
            src=" https://amilce2023.github.io/labreports/finalmoduleimage1.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Sierpeński triangles generated by the chaos game algorithm.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
		
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
	    
        <section id="code">
	<pre><code class="language-python">  
 # Define tetrahedron vertices
vertices = [
    (0, 0, 0),                         
    (2, 0, 0),                         
    (1, np.sqrt(3), 0),               
    (1, np.sqrt(3) / 3, np.sqrt(6)/3)  
]

# Parameters
iterates = 10000  
frames = 350
points_per_frame = iterates // frames

# Generate points
points = np.zeros((iterates, 3))
points[0] = [random() * 2, random() * np.sqrt(3) / 3, random() * (np.sqrt(6) / 3)]
for i in range(1, iterates):
    k = randint(0, 3)
    points[i] = midpoint(vertices[k], points[i - 1])

# Rotation function
def rotate_points(points, angle_x, angle_y, angle_z):
    rotation_x = np.array([
        [1, 0, 0],
        [0, np.cos(angle_x), -np.sin(angle_x)],
        [0, np.sin(angle_x), np.cos(angle_x)]
    ])
    rotation_y = np.array([
        [np.cos(angle_y), 0, np.sin(angle_y)],
        [0, 1, 0],
        [-np.sin(angle_y), 0, np.cos(angle_y)]
    ])
    rotation_z = np.array([
        [np.cos(angle_z), -np.sin(angle_z), 0],
        [np.sin(angle_z), np.cos(angle_z), 0],
        [0, 0, 1]
    ])
    rotation_matrix = rotation_z @ rotation_y @ rotation_x
    return points @ rotation_matrix.T

  # Prepare plot
fig = plt.figure(figsize=(6, 6))
ax = fig.add_subplot(111, projection='3d')
scatter = ax.scatter([], [], [], s=0.1, c=[], cmap='viridis')
ax.set_xlim(0, 2)
ax.set_ylim(0, np.sqrt(3))
ax.set_zlim(0, np.sqrt(6)/3)
ax.set_title("Rotating Sierpinski Tetrahedron", fontsize=14)
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
ax.set_zlabel('Z-axis')
ax.view_init(elev=30, azim=30)

# Create animation
ani = FuncAnimation(fig, update, frames=frames, interval=50, blit=False)

# Save as GIF
gif_path = "sierpinski_tetrahedron_rotating.gif"
ani.save(gif_path, writer=PillowWriter(fps=20))

# Display the GIF
display(Image(filename=gif_path))
		
	</code></pre>
Above are code snippets that shows how the Sierpeński triangle code generated by the chaos algorithm was modified and extended to 
creating a Sierpeński triangle pyramid that is rotating around its base. The extended code transforms the original Sierpinski triangle 
into a 3D Sierpinski tetrahedron to improve the fractal generation with additional complexity and visual appeal. The definition of 
tetrahedron vertices was created in 3D space then we increased the number of iterations for smoother points generation and introduced 
a rotation function to animate the structure in three dimensions. The plotting mechanism was updated to create a 3D scatter plot while 
a new animation framework was implemented to visualize the rotating tetrahedron and save it as a GIF. The results can be seen in the
results and analysis section.

<figure>
          <img
            src=" https://amilce2023.github.io/labreports/finalmoduleanimation1.gif"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Results of applying the transformation function in the first iteration.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

 <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module6image3.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Results of applying the transformation function in the second iteration.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

 <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module6image4.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Results of applying the transformation function in the third iteration.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
</code></pre>
Since the code in this experiment is about applying iterative transformation to points in the plane, we have many
ways in which we can modify and extend this code. The function for the transformation is z = z<sup>2</sup> - 0.5. 
We could extend the code by applying the transformation (z<sup>n</sup> + k), but this will result in a great 
deal of images to analyze, we could analyze the results based on the parity of n and k. To avoid that cumbersome
work, we simplify enhance the code and extend it ot create an animation. The code modified code is given below 
and we will analyze it in the results and analysis section.
	</p>
		
 <section id="code">
	<pre><code class="language-python"> 
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import Image, display
import matplotlib.cm as cm

def generate_grid(size):
    x = np.linspace(-1, 1, size)
    y = np.linspace(-1, 1, size)
    grid = np.meshgrid(x, y)
    return grid

def iterative_transform(grid, iterations):
    x_grid, y_grid = grid
    z = x_grid + 1j * y_grid
    for i in range(iterations):
        z = z ** 2 - 0.5   
    return np.real(z), np.imag(z)

def update(frame):
    plt.clf()   
    fractal_grid = iterative_transform(grid, frame + 1)
    x_fractal, y_fractal = fractal_grid
    
    norm = plt.Normalize(vmin=-1, vmax=1)
    colors = cm.plasma(norm(x_fractal)) 
     
    plt.scatter(x_fractal, y_fractal, s=1, color=colors.reshape(-1, 4))
    plt.title(f'Iteration: {frame + 1}', fontsize=16)
    plt.xlim(-1, 1)
    plt.ylim(-1, 1)

size = 50
grid = generate_grid(size)

fig = plt.figure(figsize=(10, 10))
ani = FuncAnimation(fig, update, frames=3, repeat=True)
 
gif_filename = 'fractal_animation.gif'
ani.save(gif_filename, writer='pillow', fps=1)
 
display(Image(filename=gif_filename))

</code></pre>
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
The extend chaos game code created a 3D Sierpinski tetrahedron using the chaos game algorithm to turn it into fractals. Generation the 
points involves using the midpoint formula 
<p>
M = &lt; (P<sub>x</sub> + Q<sub>x</sub>) / 2, (P<sub>y</sub> + Q<sub>y</sub>) / 2, (P<sub>z</sub> + Q<sub>z</sub>) / 2 &gt;
</p>
where M is the midpoint between points P and Q. The tetrahedron's vertices are defined in a 3D coordinate system, with the base vertices
at (0, 0, 0), (2, 0, 0), and (1, √3, 0), and the apex at (1, √3/3, √6/3). The code generates points iteratively by randomly selecting a 
vertex and moving to the midpoint between that vertex and the last point, effectively creating a dense set of points that approximate the
fractal. In addition, the code incorporates a rotation mechanism using rotation matrices for the x, y, and z axes, which are combined to 
achieve a full 3D rotation.
<p>
R = R<sub>z</sub> • R<sub>y</sub> • R<sub>x</sub>
</p>
where R<sub>x</sub>, R<sub>y</sub>, and R<sub>z</sub> represent the rotation matrices around the respective axes. The results can be seen
below
	      
        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/finalmoduleanimation1.gif"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> An animated GIF obtained by modifying and enhancing the original code.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>   
      
      </section>



      <!-- CONCLUSION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
To sum everything, this lab consisted in generating a 2D grid of points on which we apply a complex iterative
trabsformation that resulted in afractal pattern. We used many iterations to be able to visualize different pattern
generated by the transformation. We try to change the function in order to make different observations based on a 
formula for a general transformation function z<sup>n</sup> + k and analyze the results based on the parity on n and k.
		
         </p>
      </section>

     
     

      <!-- REFERENCE SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>References</h2>
        <p>     
        https://colab.research.google.com/drive/19huv_p4UO5jyIK9MrtaZLKNIHwUgKuwP#scrollTo=SWb9_eFf-pjp

	</p>
     
     
  </main>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
