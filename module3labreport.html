


<!-- INTRODUCTION SECTION -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link 
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
  />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    }
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">




  <header>
    <h1>Fractal Geometry</h1>
       <h1>Module 3 Lab Report</h1>
    <p class="author">
      Annkid Joseph Milcé <br />
      02/26/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This is a report for module 3 of the course Fractal Geometry. In this module we are 
	  experimenting with a Colab code that allows us to draw an equilateral triangle which we will
	  recursively subdivide into smaller equilateral triangles to create an interesting self-similar 
	  fractal known as Sierpiński triangle or Sierpiński gasket or Sierpiński sieve. In this lab report
	  we will also apply Python codes to generate a cellular, a tessellation structures with a wide range
	  of application in physics, biology, and microstructure modeling. In the next section, we will 
	  explain the different segment of the codes that were used.
        </p>

</section>

      <!--Three Sides of a Triangle & Sierpiński Triangle-->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="Sierpiński Triangle">
      
      
        <h2>Sides of a Triangle & Sierpiński Triangle</h2>
        <p>
	In this section, we are documenting the codes that will create the sides of the equilateral triangle 
	and the sierpiński triangle. Take a look at the first code segment below:
	</p>
	      
	<section id="code">
	<pre><code class="language-python">                

	!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
from turtle_setup import *
	def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)

  	show()
	</code></pre>
	Since we are using turtle logo graphics for visualition, the segment of the code above first 
	ensures that we import the necessary library to perform the experiment. After we imoport the turtle 
	logo library, we define a function that will creat the triangle. The "for" loop enables the turtle
	to draw the three sides of triangle with a forward motion that includes left turns of 120 degrees.
        </p>

	<section id="code">
	<pre><code class="language-python">
	 initializeTurtle()
         showturtle()
		
         </code></pre>
	 </p>
	This portion of the code initialize the turtle graphics followed buy the showturtle() function
	that is meant to help the user visualize the turtle on the canvas.
	</p>

	<section id="code">
	<pre><code class="language-python">
	 def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)

          jump(300, 500)
face(90)
color('green')
length = 400
draw_triangle(length)

show()
      </code></pre
      </p>
	This code segment set up the turtle and guided its motion on the canvas. Once we have defined 
	the function that will draw the triangle, we make sure that the turtle is at coordinate 
	(300, 500), its face is at a 90-degree angle, and enable it to draw a green triangle will 
	400 pixels in length. The show() function is used for visualization.
	</p>

    <section id="code">
      <pre><code class="language-python">
	 def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

	initializeTurtle()
showturtle()

jump(300, 500)
face(90)
color('green')

length = 400
order =4
sierpinski_triangle(length, order)

show()
     </code></pre
     </p>
         This code fragment first consists of defining the function for the sierpeński triangle.
	 It includes a conditional statement that sets the order of the sierpeński triangle. If
	 the order is zero, then the turtle will just draw an equilateral triangle. Otherwise,
	 the turtle will subdivide the original equilateral triangle based on the given order.
	 In this experiment, we set the order to be four which means that the central smaller
	 triangles will be removed from the bigger original triangle whose side length is 400 
	 pixels, four times. When the order of the sierpeński is not zero, we need to define the 
	 length of the smaller triangles. The code ensure each new length is the previous length 
	 divided by 2 at each order level. The left and right commands ensure that each interior
	 angle is 60 degrees as the vertices of the triangles are drawn by the turtle. To start 
	 the shape, we reinitializes the turtle in the positions at the coordinate (300, 500),
	 colored the shape in green, and set the turtle's face 90 degrees forward.
     </p>

    </code></pre>
    </p>
	Below we provide a modified and extended version of the code for the sierpiński triangle.
    </p>

<section id="code">
      <pre><code class="language-python">
!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
from turtle_setup import *
import random

def draw_triangle(length, color):
    fillcolor(color)  
    begin_fill()    
    for _ in range(3):
        forward(length)
        left(120)
    end_fill()       

initializeTurtle()
showturtle()

def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length, random_color())
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

def random_color():
    return f'#{random.randint(0, 0xFFFFFF):06x}'

length = int(input("Enter the length of the triangle: "))
order = int(input("Enter the order of the Sierpinski triangle (0-5): "))

jump(300, 500)
face(90) 

sierpinski_triangle(length, order)

show()
</code></pre
     </p>
	The code above improves the visual appearance and the interactivity of the code.
	A draw_triangle function was used to allow a color parameter to set the fill color
	for each triangle while a random_color fucntion generates a random hex color for each
	triangle to allow room for variety in the visualization. The change allows the user to 
	be able to enter a length and an order for the triangle within the range of 0-5. 
</p>
	
</section>

      <!-- Cellular Automata -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="Celullar Automata">
      
        <h2>Cellular Automata</h2>
        <p>
	In this section, we are now looking at the code that will help us visualize a 
	cellualar automaton. The first code segment is documented below:
	<p>
		
       <section id="code">
       <pre><code class="language-python">
      import numpy as np
import matplotlib.pyplot as plt

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()
       </code></pre>
       </p>
	       
       The code above starts by importing two important libraries: the numpy and matplotlib libraries.
       The numpy library is used to facilitate numerical operations while the matplotlib will be used
       for plotting. In that segment of code, the plot(x) function will plot a 2D array as a grayscale
       color map with the axis hidden using the ax.axis(off) and the plt.show() function to
       visualize the plot. The 2D array represents the 10 x 10 cellular automaton grid. It is to note
       that aspect="auto" is used to keep correct proportions.

  <section id="code">
     <pre><code class="language-python">
   C = np.zeros((100,100)).astype(int)
C[0,50] = 1
plot(C)

num = 90
print(f'{num:08b}')

rule = np.zeros((2,2,2))

rule[0,0,0] = 0
rule[0,0,1] = 1
rule[0,1,0] = 0
rule[0,1,1] = 1
rule[1,0,0] = 1
rule[1,0,1] = 0
rule[1,1,0] = 1
rule[1,1,1] = 0
       </code></pre>
       </p>
	
     <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
	  
       The code above redefines the array. It now in itializes a 100 x 100 array that is filled with zeros.
       C[0, 50] = 1 sets an initial condition that a single cell represents a "1" in the middle of the first row.
       It also prints the binary representation of the number 90 using the function num = 90 and print the result 
       which is given by 01011010. A rule was applied using the function rule = np.zeros((2, 2, 2)) as a way to 
       initialize a 3D array to hold the rule cellular automaton. The rule is define in the remaining portion 
       of the code where each position corresponds to the state of the three neighboring cells.
  </p>

 <section id="code">
     <pre><code class="language-python">	
    def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            N  = X[i-1,j]
            NW = X[i-1,j-1]
            NE = X[i-1,j+1]

            X[i,j] = rule[NW,N,NE]

    return X

plot(CA(C))
 </code></pre>
       </p>
       This code segment uses the function CA(X) to to apply the rule for the cellular automaton to the array.
       It is followed by two "for" loops that will iterate the over the rows and the columns. Each iteration on 
       the rows exlcudes the first row and the the first column, and the function X[i, j] update the state of
       of the cell based on the rule and neighboring states. observe that N, NW, and NE are defined to get
       the states of the neighboring cells. N gets the state of the current cell above, NW gets the state of
       the upper-left cell, and NE gets the state of the upper-right cell. The function "return X" will return
       the update array and the function "plot(CA(C))" helps visualize the results. 
 </p>
	 
 <section id="code">
     <pre><code class="language-python">
	     
def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            X[i,j] = (rule/(2**(4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]))) % 2

    return X

rule = 90

plot(CA(C))

for rule in [30, 62, 90, 110, 126]:
    plot(CA(C))
     </code></pre>
     </p>
	
 </section>
 <!-- --------------------------------------------------------------------------------------------------- -->
 <!-- --------------------------------------------------------------------------------------------------- -->
 <!-- --------------------------------------------------------------------------------------------------- -->
 <!-- --------------------------------------------------------------------------------------------------- -->
    This last segment of code does a similar job to the previous code segment. It uses a fucntion that 
    applies the the cellular automaton rules to the the array but it is implemented in a different way 
    as can be seen the provided codes. It sets a rule number; namely the number 90 and plot the the results
    of the cellular automaton by applying the plot(CA(C)) function to plot the results. The experiment is
    concluded by running the cellular automaton for different rules for rule 30, 62, 90, 110, and 126 and 
    by using the plot(CA(C)) to see the results. 
     </p>

      </section>
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
	Now we look forward to documenting the modified version of the code for the cellular automaton. 
  </p>
	  
 <section id="code">
     <pre><code class="language-python">
	     
import numpy as np
import matplotlib.pyplot as plt

def plot(x, title):

    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap='gray', interpolation='none')
    ax.axis('off')
    ax.set_title(title, fontsize=16)
    fig.set_size_inches(10, 10)
    plt.show()

def initialize_grid(size):
     
    C = np.zeros((size, size), dtype=int)
    C[0, size // 2] = 1
    return C

def get_rule(rule_number):
     
    binary_rule = np.array(list(np.binary_repr(rule_number, width=8)), dtype=int)[::-1]

    rule_array = np.zeros((2, 2, 2), dtype=int)
    for i in range(8):
        pattern = f'{i:03b}' 
        nw, n, ne = map(int, pattern)
        rule_array[nw, n, ne] = binary_rule[i]
   
    return rule_array

def CA(X, rule):
    
    rule_array = get_rule(rule)
   
    for i in range(1, X.shape[0]-1):
        for j in range(1, X.shape[1]-1):
            NW = X[i-1, j-1]
            N  = X[i-1, j]
            NE = X[i-1, j+1]
            X[i, j] = rule_array[NW, N, NE]

    return X

def run_simulation(rule, generations=100):
     
    size = generations
    C = initialize_grid(size)
   
    for gen in range(generations):
        if gen % 10 == 0:
            plot(C, f'Rule {rule} - Generation {gen}')
        C = CA(C, rule)
   
    plot(C, f'Rule {rule} - Final Generation')

rules_to_simulate = [30, 62, 90, 110, 126]

for rule in rules_to_simulate:
    run_simulation(rule, generations=100)
     </code></pre>
       </p>
	Above is a modified version of the original code that enhance it provide clarity, functionality,
	and interactivity. With that version, the user is able to select different rules and is able to
	visualize the results over many generations. To improve the code readbility, the separate function
	initialize_grid was used and the run_simulation function was introduced to handle the process of
	initializing the grid, applying the rule, and plotting the results over a given number of generations.
	A second modification was to that of adding the get_rule funtion in orderto facilitate the application 
	of rules to the cellular automaton by converting a rule number into a 3D array. To easily identify each
	plot, titles are included to indicate the current generation along with the rule number. It is worth 
	notice that plots are generated for every 10 generations as a way to reduce clutter and to focus on
	significant changes as time elapses. The final generation is plotted after all iterations to give a 
        clear view of the final state of each rule. 
	 
      </section>
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
         
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
         The first portion of the code was meant to create some random paths drawn by moving the turtle 
	 in different dirrections at different angles. Observe from the picture in Figure 1 how chaotic
	 the paths are. This is explained by the randomness of the movement of the turtle resulting in an
	 unorganised shape.

		
        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module2image1.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Picture of the random walk performed by the turtle.
          </figcaption>
        </figure>

      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
        To organize the random walk, we apply the blip lines function in order to rearrange the paths into 
	a fractal-like shape. Figure 2 shows the starting point of the process in which the code was modified
	to transform the random walk into a blip lines of order 1 consisting of downward and upward slopes.

	<!-- --------------------------------------------------------------------------------------------------- -->
        </p>

        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module2image2.png"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Initial line to create the path of the turtle with blips between the lines.
          </figcaption>
        </figure>
	
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
	The next two pictures illustrate how the code was modified to now reorganize the random walk into 
	a more intricate shape by creating blip lines of order 2 and order 3. Observe that at this point,
	the walk start assuming a fractsal-like pattern.

      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module2image3.png"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Path created by the turtle with blip lines of orders 1 and 2.
            <strong></strong> Blit lines of colors red are of oder 1 while blit lines of order 2 are in blue.              
		  
          </figcaption>
        </figure>

      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module2image4.png"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Starting the snowflake fractal by creating blit lines of order 3.
	     
          </figcaption>
        </figure>

      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
	Figure 5 shows how the random walk become increasing more complex as we apply the Koch Curve function
	of different order to create a snowflake fractal showcasing the self-similarity patterns depicted in 
	fractals.
	    
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module2image5.png"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Applying the Koch Curve function to create a Snowflake fractal.
          </figcaption>
        </figure>

      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

	Finally, we use the Dragon Curve function to illustrate a more unique pattern in the shape of a dragon.
	This results in an even more complex shape than the previous ones. Over all, the picture in Figurew 6 
	combines all the results from Figures 1, 2, 3, 4, and 5 to produce a dynamic visual representsation 
	of the random walk by creating fractals-like patterns. The result combines different mathematical
	concepts, such as recursion, self-similarity, and transformations. 

	  <!-- --------------------------------------------------------------------------------------------------- -->
        </p>	
        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module2image6.png"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Applying the dragon curve function to transform the snowflake fractal
	    <strong></strong> into a dragon-shape fractal.
		  
          </figcaption>
        </figure>
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>



    </section>
       </p>
	Below we provide an extension of the code.
       </p>
	      

      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">
	                  
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

import random
import math

def random_color():
    r = random.random()
    g = random.random()
    b = random.random()
    return color_rgb(r, g, b)

def draw_polygon(n_sides, side_length):
    angle = 360 / n_sides  
    for _ in range(n_sides):
        forward(side_length)
        right(angle)

start_x = 100  # Start at x = 200 
start_y = 300  # Start at y = 300 
jump(start_x, start_y)  

side_length = 20   
spacing = 20   
for n_sides in range(3, 20):
    color(random_color())   
    draw_polygon(n_sides, side_length)   
    penup()   
    jump(getx() + spacing + side_length, start_y)   
    pendown()   

show()
	</code></pre>


		
     </section>


	      
	We first set up the dimensions of the canvas which in this experiment is an 800 X 1000 rectangle.
	In the second portion of the code, we import the random() and math() libraries that help 
	selecting random colors and help with the mathematical steps needed to draw the polygons. 
	The third section of the code is really crucial because in there we defined the polygon
	with its number of sides and sides length. We use the formula angle = 360/n to measure the 
	exterior angles of each polygon followed by a "for" loop deifned the sides length and the 
	exterior angles for each new polygon. The penultimate part of the code has a "for" loop that 
	set the polygons from a triangle, a 3-sided polygon to an icosagon, a 20-sided polygon. 
	The penup() and pendown() commands indicates whether the turtle picks up the tail of the 
	turtle so that it draws or do not draw the shapes, respectively. The ultimate portion of
	the code uses the show() function to print the polygons as can be seen below.
	      


	        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/movingpolygons.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Moving Polygons created by the turtle in the canvas.
          </figcaption>
        </figure>
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
      
      </section>



      <!-- CONCLUSION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
	In conclusion, this report highlights the steps that we used to generate a code that introduce us to 
	Logo to the Logo programming langiage via the use of Turtle Graphics. We experimented with three codes
	segments. The first part of the code was provide and we used to visualize a square drwan by a turtle
	moving on a canvas. In the second section of the experiment, we modified the given code to create a
	bigger square at a different location with a different colors for the background and the square.
	At the end, we experimented with a different code segment that allows us to create moving polygons
	from a triangle to an icosagon. This was a fascinating experiment in wehich we learn how to command 
	the computer to do what we want it to do; a cool way to learn from experiments and observations.
		
         </p>
      </section>

     
     

      <!-- REFERENCE SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>References</h2>
        <p>     
        https://en.wikipedia.org/wiki/Logo_(programming_language)

	</p>
      
      </section>
		
	https://www.youtube.com/watch?v=NGmNvRXMhac
   
         </p>
	    
     
     
  </main>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
