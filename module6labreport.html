 

<!-- INTRODUCTION SECTION -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------------- -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link 
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
  />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    }
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">




  <header>
    <h1>Fractal Geometry 
	    Module 6 Lab Report</h1>
    <p class="author">
      Annkid Joseph Milc√© <br />
      04/11/2025
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
This is a report for module 6 of the course Fractal Geometry. In this module we experiment with a Colab whose purpose
is to generate a set of points that we would visualize as a 2D grid. We also see how we can creste complex patterns
by applying an iterative mathematical trsansformation to the points. We below, we provide and document the code that 
is used to attain that objective.
        </p>
     
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<!-- ------------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">                
import numpy as np
import matplotlib.pyplot as plt

def generate_grid(size):
    x = np.linspace(-1, 1, size) 
    y = np.linspace(-1, 1, size)
    grid = np.meshgrid(x, y)   
    return grid

def plot_grid(grid):
    x_grid, y_grid = grid
    plt.figure(figsize=(10, 10))
    plt.scatter(x_grid, y_grid, s=1, color='blue') 
    plt.title(f'2D Grid of {len(x_grid)}x{len(y_grid)} points')
    plt.show()

size = 50   
		
grid = generate_grid(size)
plot_grid(grid)
	</code></pre>
In the code above, we first import the necessary libraries. We import n"numpy" as "np" as the library that will
be used to manipulate the 2D array and to handle numerical operations. We also import "matplotlib.pyplot" to plot
and visualize the resulting image. Next, we define the function "generate_grid" which will create the points whose 
size is the number of points along the x and y axes. The command "np.linspace" ensures that the points are evenly sized
while the command "np.meshgrid" generate the rectangular grid out of the x and y coordinates. The "return" command
returns a tuple of 2D arrays to represent the coordinates of the grid. Te remainder of this code section defines a new 
function called "plot_grid" whose purpose is to plot the 2D grid. This function creates a new figure with a specific
size where "s" sets the points' size and "color" color colors the points in blue. It also ensures that the plot is 
displayed and that a title is inserted to indicste the dimensions of the grid. The final portion of the code sets the 
grid size to 50, calls the function "generate_grid" to create the grid and calls the function "plot_grid" in order to 
visualize the results as can be seen below.
</p>

<figure>
          <img
            src=" https://amilce2023.github.io/labreports/module6image1.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> A 50 x 50 grid generated by the first portion of the code.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
		
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------- -->
	    
        <section id="code">
	<pre><code class="language-python">  
 def iterative_transform(grid, iterations):
    x_grid, y_grid = grid
    z = x_grid + 1j * y_grid  # Create a complex plane
    for i in range(iterations):
        z = z ** 2 - 0.5  # Iteratively apply the transformation
    return np.real(z), np.imag(z)

iterations = 1
fractal_grid = iterative_transform(grid, iterations)
plot_grid(fractal_grid)

iterations = 2
fractal_grid = iterative_transform(grid, iterations)
plot_grid(fractal_grid)

iterations = 3
fractal_grid = iterative_transform(grid, iterations)
plot_grid(fractal_grid)
		
	</code></pre>
The code above is the portion in which the iterative transformation is applied. The function "iterative_transform"
combines the x and y coordinates into a complex number z. The function ensures that z is updated uisng the formula
z = z<sup>2</sup> - 0.5 for the specified number of iterations. Three different iterations were done which means 
that the transformation was applied three times. Each iteration calls the the "iterative_transform" function to 
generate the grid followed a call of the "plot_grid" function to visualize the results. The image obtained form 
each iteration is displayed below.

<figure>
          <img
            src=" https://amilce2023.github.io/labreports/module6image2.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Results of applying the transformation function in the first iteration.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

 <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module6image3.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Results of applying the transformation function in the second iteration.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>

 <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module6image4.png"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> Results of applying the transformation function in the third iteration.
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
</code></pre>
Since the code in this experiment is about applying iterative transformation to points in the plane, we have many
ways in which we can modify and extend this code. The function for the transformation is z = z<sup>2</sup> - 0.5. 
We could extend the code by applying the transformation (z<sup>n</sup>n + k), but this will result in a great 
deal of images to analyze, we could analyze the results based on the parity of n and k. To avoid that cumbersome
work, we simplify enhance the code and extend it ot create an animation. The code modified code is given below 
and we will analyze it in the results and analysis section.
	</p>
		
 <section id="code">
	<pre><code class="language-python"> 
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import Image, display
import matplotlib.cm as cm

def generate_grid(size):
    x = np.linspace(-1, 1, size)
    y = np.linspace(-1, 1, size)
    grid = np.meshgrid(x, y)
    return grid

def iterative_transform(grid, iterations):
    x_grid, y_grid = grid
    z = x_grid + 1j * y_grid
    for i in range(iterations):
        z = z ** 2 - 0.5   
    return np.real(z), np.imag(z)

def update(frame):
    plt.clf()   
    fractal_grid = iterative_transform(grid, frame + 1)
    x_fractal, y_fractal = fractal_grid
    
    norm = plt.Normalize(vmin=-1, vmax=1)
    colors = cm.plasma(norm(x_fractal)) 
     
    plt.scatter(x_fractal, y_fractal, s=1, color=colors.reshape(-1, 4))
    plt.title(f'Iteration: {frame + 1}', fontsize=16)
    plt.xlim(-1, 1)
    plt.ylim(-1, 1)

size = 50
grid = generate_grid(size)

fig = plt.figure(figsize=(10, 10))
ani = FuncAnimation(fig, update, frames=3, repeat=True)
 
gif_filename = 'fractal_animation.gif'
ani.save(gif_filename, writer='pillow', fps=1)
 
display(Image(filename=gif_filename))

</code></pre>
      </section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
To modify and extend the code, we first imported the essential libraries that will facilitate the results that we 
desire. We imported "numpy" for easy operations, "matplotlib.pyplot" to plot the results, "FuncAnimation" to animate
the figure, and we used matplotlib.cm to access a color map to enhance the cokor of the results. An important function
for this experiment is the "iterative_transform()" function. That functions is the basis for the computaions as it
it takes the 2D grid and a specified number of iterations as input. It applies the transformation function 
$z = z<sup>2</sup> - 0.5$ to genersate fractal-like structures by transforming the points into complex numbers.
changing the results into an animation allows to the user to observe how fractals evolve in a more engaging environment
than the user would in a static environment like the the results generated by the original code. Using color map allows
for a vibrant visualization that makes the interpreting the structes oif the resulted fractal more appealing. We played 
with the code by changing the transformation function to use other exponents for the generalized transformation function
$z = z<sup>n</sup> + k$ and attempt to see what would happen for different values of $n$ and $k$ including possible 
combination of these values. We based our observations on the parity of $n$ and $k$. 


      </section>
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
        In the modified portion of the code, the same functions and commands were used. However, the
        turtle starting position was set at the coordinates (500, 500) using the the command jump 
	(500, 500). We also increased the sides length of the square by 200 units more and turned the
	turtle 270 degrees to the right. We also changed the background color from white to sky blue,
	and make the pen clor white. 
	      
	      

	
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>
	The results from the modified and extended code can be seen in the diagrams below.



        <figure>
          <img
            src=" https://amilce2023.github.io/labreports/module6animation.gif"
            width="1000"
            height="800"
            loading="lazy"
          />
          <figcaption>
            <strong></strong> An animated GIF obtained by modifying and enhancing the original
          </figcaption>
        </figure>
	      
      <!-- --------------------------------------------------------------------------------------------------- -->
        </p>   
      
      </section>



      <!-- CONCLUSION SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
	In conclusion, this report highlights the steps that we used to generate a code that introduce us to 
	Logo to the Logo programming langiage via the use of Turtle Graphics. We experimented with three codes
	segments. The first part of the code was provide and we used to visualize a square drwan by a turtle
	moving on a canvas. In the second section of the experiment, we modified the given code to create a
	bigger square at a different location with a different colors for the background and the square.
	At the end, we experimented with a different code segment that allows us to create moving polygons
	from a triangle to an icosagon. This was a fascinating experiment in wehich we learn how to command 
	the computer to do what we want it to do; a cool way to learn from experiments and observations.
		
         </p>
      </section>

     
     

      <!-- REFERENCE SECTION -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <!-- --------------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>References</h2>
        <p>     
        https://en.wikipedia.org/wiki/Logo_(programming_language)

	</p>
      
      </section>
		
	https://www.youtube.com/watch?v=NGmNvRXMhac
   
         </p>
	    
     
     
  </main>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>

